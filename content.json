{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://michael-scofield-c.github.io","root":"/"},"pages":[],"posts":[{"title":"利用群辉套件做远程监控","slug":"利用群辉套件做远程监控","date":"2019-12-30T12:36:33.000Z","updated":"2019-12-30T13:13:17.564Z","comments":true,"path":"2019/12/30/利用群辉套件做远程监控/","link":"","permalink":"https://michael-scofield-c.github.io/2019/12/30/%E5%88%A9%E7%94%A8%E7%BE%A4%E8%BE%89%E5%A5%97%E4%BB%B6%E5%81%9A%E8%BF%9C%E7%A8%8B%E7%9B%91%E6%8E%A7/","excerpt":"","text":"用群辉nas做服务器使用的是海康的摄像头，关于硬件的上的东西我不是很懂，这方面还是有很多东西需要学习。 通过网页后台登录到群辉服务器使用管理员账号登录到后群辉后台在浏览器中键入群辉的IP地址和端口号，使用管理员登录到群辉后台 在套件中心安装Surveillance Station套件 通过主菜单可以找到SurveillanceStation。 安装网络摄像头的添加过程选择网络摄像机 点选添加摄像机，可以选择快速设置或者完整设置： 快速设置：点选搜索按钮可以搜索到局域网内的摄像头，但是我暂时不知道为什么在我这里搜索不到，所以选择了完整设置。 完整设置：在完整设置上也存在搜索不到的情况，所以使用以下方法添加摄像头： 点选品牌下的用户自定义，出现如下内容： 在路径中输入摄像机品牌的rtsp。常见摄像头的rtsp格式，点击测试连接出现图像已经打钩表示道路通畅。 点击下一步，查看视频编码是否是H.264，H.265不能播放。 PS 一些杂群辉后台忘记密码重置密码，拿一根针一类的在群辉机子后面的RESET上插4S，出现滴滴声放开，不放开太久了会直接重置群辉的后台。 使用管理员修改用户权限通过控制面板中的用户账号中修改用户拥有权限。 出现在添加完成之后不能播放的情况使用浏览器进入摄像头后台，后台地址为摄像头分配到的IP地址。修改配置-&gt;音视频下，将视频编码修改为H.264。 群辉摄像头的添加数量免费只有两个，需要更多需要购买许可证，很贵。","categories":[],"tags":[{"name":"网络摄像头","slug":"网络摄像头","permalink":"https://michael-scofield-c.github.io/tags/%E7%BD%91%E7%BB%9C%E6%91%84%E5%83%8F%E5%A4%B4/"},{"name":"群辉","slug":"群辉","permalink":"https://michael-scofield-c.github.io/tags/%E7%BE%A4%E8%BE%89/"},{"name":"远程监控","slug":"远程监控","permalink":"https://michael-scofield-c.github.io/tags/%E8%BF%9C%E7%A8%8B%E7%9B%91%E6%8E%A7/"}]},{"title":"SpringBoot学习过程（二）","slug":"SpringBoot学习过程（二）","date":"2019-12-30T12:29:13.000Z","updated":"2019-12-30T12:30:20.342Z","comments":true,"path":"2019/12/30/SpringBoot学习过程（二）/","link":"","permalink":"https://michael-scofield-c.github.io/2019/12/30/SpringBoot%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"SpringBoot Filter的使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.example.demo.config;import org.apache.catalina.filters.RemoteIpFilter;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;@Configurationpublic class WebConfiguration &#123; @Bean public RemoteIpFilter remoteIpFilter()&#123; return new RemoteIpFilter(); &#125; @Bean public FilterRegistrationBean testFilterRegistration()&#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new MyFilter()); registration.addUrlPatterns(\"/*\"); registration.addInitParameter(\"paramName\", \"paramValue\"); registration.setName(\"MyFilter\"); registration.setOrder(1); return registration; &#125; public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request=(HttpServletRequest)servletRequest; System.out.println(\"this is MyFilter,url:\"+request.getRequestURI()); System.out.println(\"结果是：\"+request.getParameter(\"MyFilter\")); filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; &#125; &#125;&#125; 自定义Property配置在application.properties或者application.yaml中12com.neo.title=纯洁的微笑com.neo.description=分享生活和技术 自定义配置类： 12345678910@Componentpublic class NeoProperties &#123; @Value(\"$&#123;com.neo.title&#125;\") private String title; @Value(\"$&#123;com.neo.description&#125;\") private String description; //省略getter settet方法&#125; log配置1234logging.path=/user/local/loglogging.level.com.favorites=DEBUGlogging.level.org.springframework.web=INFOlogging.level.org.hibernate=ERROR JPA数据库操作Jpa 是利用 Hibernate 生成各种自动化的 sql，如果只是简单的增删改查，基本上不用手写了，Spring 内部已经帮大家封装实现了。 1、添加相应的jar包 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 添加配置文件（下面出现的错误在这里都是已经修改好的了）： 12345678spring.datasource.url=jdbc:mysql://localhost:3306/test_demo?serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=hadun123spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.jpa.properties.hibernate.hbm2ddl.auto=createspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialectspring.jpa.show-sql= true 关于spring.jpa.properties.hibernate.hbm2ddl.auto的值： create： 每次加载 hibernate 时都会删除上一次的生成的表，然后根据你的 model 类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 create-drop ：每次加载 hibernate 时根据 model 类生成表，但是 sessionFactory 一关闭,表就自动删除。 update：最常用的属性，第一次加载 hibernate 时根据 model 类会自动建立起表的结构（前提是先建立好数据库），以后加载 hibernate 时根据 model 类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。 validate ：每次加载 hibernate 时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 添加实体类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.example.demo.model;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import java.io.Serializable;@Entitypublic class User implements Serializable &#123; private static final long serializableUUID =1L; @Id @GeneratedValue private Long id; @Column(nullable = false,unique = true) private String userName; @Column(nullable = false) private String passWord; @Column(nullable = false,unique = true) private String email; @Column(nullable = true,unique = true) private String nickName; @Column(nullable = false) private String regTime; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassWord() &#123; return passWord; &#125; public void setPassWord(String passWord) &#123; this.passWord = passWord; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getNickName() &#123; return nickName; &#125; public void setNickName(String nickName) &#123; this.nickName = nickName; &#125; public String getRegTime() &#123; return regTime; &#125; public void setRegTime(String regTime) &#123; this.regTime = regTime; &#125; public User() &#123; &#125; public User(String userName, String passWord, String email, String nickName, String regTime) &#123; this.userName = userName; this.passWord = passWord; this.email = email; this.nickName = nickName; this.regTime = regTime; &#125;&#125; dao只要继承JpaRepository类就可以，几乎不用写方法。还有一个特别有尿性的功能非常赞，就是可以根据方法名来自动的生成 SQL，比如findByUserName 会自动生成一个以 userName 为参数的查询方法，比如 findAlll 自动会查询表里面的所有数据，比如自动分页等等。 Entity 中不映射成列的字段得加 @Transient 注解，不加注解也会映射成列 123456789package com.example.demo.dao;import com.example.demo.model.User;import org.springframework.data.jpa.repository.JpaRepository;public interface UserRepository extends JpaRepository&lt;User,Long&gt; &#123; User findByUserName(String userName); User findByUserNameOrEmail(String userName,String email);&#125; 测试结果： 1234567891011121314151617181920212223242526272829303132333435package com.example.demo;import com.example.demo.dao.UserRepository;import com.example.demo.model.User;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.text.DateFormat;import java.util.Date;@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTestpublic class UserRepositoryTest &#123; @Autowired private UserRepository userRepository; @Test public void test() throws Exception&#123; Date date=new Date(); DateFormat dateFormat=DateFormat.getDateInstance(); String formattedDate =dateFormat.format(date); userRepository.save(new User(\"aa1\",\"aa123456\",\"aa@126.com\",\"aa\",formattedDate)); userRepository.save(new User(\"bb1\",\"bb123456\",\"bb@126.com\",\"bb\",formattedDate)); userRepository.save(new User(\"cc1\",\"cc123456\",\"cc@126.com\",\"cc\",formattedDate)); Assert.assertEquals(3,userRepository.findAll().size()); Assert.assertEquals(\"cc\",userRepository.findByUserNameOrEmail(\"bb\",\"cc@126.com\").getNickName()); userRepository.delete(userRepository.findByUserName(\"aa1\")); &#125;&#125; 当让 Spring Data Jpa 还有很多功能，比如封装好的分页，可以自己定义 SQL，主从分离等等，这里就不详细讲了。 出现报错：1The server time zone value &#39;�й���׼ʱ��&#39; is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. 连接数据库的url需要添加上?serverTimezone=UTC，修改后为： 1spring.datasource.url=jdbc:mysql://localhost:3306/test_demo?serverTimezone=UTC 出现报错：1org.springframework.orm.jpa.JpaSystemException: No default constructor for entity 实体类没有默认的无参构造方法，在实体类中添加无参构造方法： 12public User() &#123;&#125; 出现错误：1java.sql.SQLIntegrityConstraintViolationException: Duplicate entry &#39;aa&#39; for key &#39;UK_ob8kqyqqgmefl0aco34akdtpe&#39; 进行多次测试，需要将字段spring.jpa.properties.hibernate.hbm2ddl.auto=create从update修改为create。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://michael-scofield-c.github.io/tags/SpringBoot/"},{"name":"基础","slug":"基础","permalink":"https://michael-scofield-c.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习","slug":"学习","permalink":"https://michael-scofield-c.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"SpringBoot学习过程（一）","slug":"SpringBoot学习过程（一）","date":"2019-12-30T12:20:38.000Z","updated":"2019-12-30T12:27:03.150Z","comments":true,"path":"2019/12/30/SpringBoot学习过程（一）/","link":"","permalink":"https://michael-scofield-c.github.io/2019/12/30/SpringBoot%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"SpringBoot中使用MockMvc做接口测试123456789101112131415161718192021222324252627282930313233package com.example.demo;import com.example.demo.controller.HelloWorldController;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.http.MediaType;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;@RunWith(SpringRunner.class)@SpringBootTestpublic class HelloTest &#123; private MockMvc mvc; @Before public void setUp() throws Exception&#123; mvc= MockMvcBuilders.standaloneSetup(new HelloWorldController()).build(); &#125; @Test public void getHello() throws Exception&#123; mvc.perform(MockMvcRequestBuilders.get(\"/hello\").accept(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().string(\"hello\")); &#125;&#125; SpringBoot做热部署12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://michael-scofield-c.github.io/tags/SpringBoot/"},{"name":"基础","slug":"基础","permalink":"https://michael-scofield-c.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习","slug":"学习","permalink":"https://michael-scofield-c.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"HELLO WORLD","slug":"hello-world","date":"2019-12-29T18:10:40.000Z","updated":"2019-12-30T12:27:31.975Z","comments":true,"path":"2019/12/30/hello-world/","link":"","permalink":"https://michael-scofield-c.github.io/2019/12/30/hello-world/","excerpt":"","text":"第一篇文章&gt;…HELLO WORLD","categories":[],"tags":[{"name":"开始","slug":"开始","permalink":"https://michael-scofield-c.github.io/tags/%E5%BC%80%E5%A7%8B/"},{"name":"记录","slug":"记录","permalink":"https://michael-scofield-c.github.io/tags/%E8%AE%B0%E5%BD%95/"}]}]}